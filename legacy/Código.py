# -*- coding: utf-8 -*-
"""gerador de portarias 2 v.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1erfHPoYDz8r0fzC_Bpq1cVhlD3CvVtn5
"""

!pip install gspread ipywidgets google-api-python-client python-docx

import re
import io
from collections import defaultdict

import gspread
import ipywidgets as widgets
from IPython.display import display, HTML

from google.colab import auth
from google.auth import default
from googleapiclient.discovery import build

from docx import Document

auth.authenticate_user()
creds, _ = default()

gc = gspread.authorize(creds)
docs_service = build("docs", "v1", credentials=creds)
drive_service = build("drive", "v3", credentials=creds)

print("✅ Autenticação concluída")

def extrair_id(link_ou_id):
    if "/" not in link_ou_id:
        return link_ou_id.strip()

    m = re.search(r"/d/([a-zA-Z0-9-_]+)", link_ou_id)
    if not m:
        raise ValueError("❌ Link inválido")

    return m.group(1)

def ler_texto_docs(link_docs):
    doc_id = extrair_id(link_docs)
    doc = docs_service.documents().get(documentId=doc_id).execute()

    texto = ""
    for elem in doc["body"]["content"]:
        if "paragraph" in elem:
            for run in elem["paragraph"].get("elements", []):
                texto += run.get("textRun", {}).get("content", "")

    return texto.strip()

link_planilha = input("Cole o link da planilha: ")
spreadsheet_id = extrair_id(link_planilha)
print("ID da planilha:", spreadsheet_id)

sheets_service = build("sheets", "v4", credentials=creds)
def listar_abas(spreadsheet_id):
    meta = sheets_service.spreadsheets().get(
        spreadsheetId=spreadsheet_id
    ).execute()
    return [s['properties']['title'] for s in meta['sheets']]
abas = listar_abas(spreadsheet_id)
print("Abas disponíveis:")
for a in abas:
    print("- ", a)

aba_escolhida = input("Digite o nome da aba desejada: ")

def ler_aba(spreadsheet_id, aba):
    result = sheets_service.spreadsheets().values().get(
        spreadsheetId=spreadsheet_id,
        range=aba
    ).execute()

    valores = result.get('values', [])
    return [l for l in valores if any(str(c).strip() for c in l)]
linhas = ler_aba(spreadsheet_id, aba_escolhida)

def normalizar_linhas(linhas):
    max_colunas = max(len(l) for l in linhas)
    linhas_norm = []

    for linha in linhas:
        nova = linha + [""] * (max_colunas - len(linha))
        linhas_norm.append(nova)

    return linhas_norm

linhas = normalizar_linhas(ler_aba(spreadsheet_id, aba_escolhida))

cabecalho = linhas[0]

checkboxes = []
for i, nome in enumerate(cabecalho):
    letra = chr(ord("A") + i)
    cb = widgets.Checkbox(description=f"{letra} – {nome}", value=True)
    checkboxes.append(cb)

display(widgets.VBox(checkboxes))

linhas_brutas = linhas
cabecalho_bruto = linhas_brutas[0]

def remover_colunas_vazias(linhas):
    colunas_validas = []
    total = max(len(l) for l in linhas)

    for i in range(total):
        if any(i < len(l) and str(l[i]).strip() for l in linhas[1:]):
            colunas_validas.append(i)

    return [[l[i] for i in colunas_validas if i < len(l)] for l in linhas]
linhas = remover_colunas_vazias(linhas)
cabecalho = linhas[0]

coluna_escola = input(
    "Digite a LETRA da coluna onde está o nome da escola (ex: A, B, C): "
).strip().upper()

idx_escola = ord(coluna_escola) - ord('A')
print("Coluna da escola:", coluna_escola, "| Índice:", idx_escola)

filtro_incluir = widgets.Text(description="Deve conter:")
filtro_excluir = widgets.Text(description="Não pode conter:")
display(filtro_incluir, filtro_excluir)

formato_documento = widgets.Dropdown(
    options=[("Tabela", "tabela"), ("Texto corrido", "texto")],
    description="Formato:"
)
display(formato_documento)

def aplicar_filtros(linhas, checkboxes, incluir, excluir):
    remover = [i for i, cb in enumerate(checkboxes) if cb.value]
    resultado = []

    for linha in linhas[1:]:
        texto = " ".join(linha).lower()
        if incluir and incluir.lower() not in texto:
            continue
        if excluir and excluir.lower() in texto:
            continue

        nova = [c for i, c in enumerate(linha) if i not in remover]
        resultado.append(nova)

    return resultado
linhas_filtradas = aplicar_filtros(
    linhas,
    checkboxes,
    filtro_incluir.value,
    filtro_excluir.value
)

from collections import defaultdict

def agrupar_por_escola(linhas, idx_escola):
    grupos = defaultdict(list)

    for linha in linhas:
        if idx_escola >= len(linha):
            continue

        escola = str(linha[idx_escola]).strip()
        if escola:
            grupos[escola].append(linha)

    return grupos
grupos_escolas = agrupar_por_escola(linhas_filtradas, idx_escola)

print("Escolas encontradas:")
for e in grupos_escolas:
    print("-", e)

def preview(linhas):
    html = "<table border='1'>"
    for l in linhas:
        html += "<tr>" + "".join(f"<td>{c}</td>" for c in l) + "</tr>"
    html += "</table>"
    display(HTML(html))
preview(linhas_filtradas)

!pip install python-docx

from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH

def criar_portaria_docx_com_anexos(texto_padrao, grupos):
    doc = Document()

    # ===== TEXTO PADRÃO =====
    for paragrafo in texto_padrao.split("\n"):
        p = doc.add_paragraph(paragrafo)
        p.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        for run in p.runs:
            run.font.name = "Arial"
            run.font.size = Pt(12)

    doc.add_paragraph("")

    # ===== ANEXOS =====
    for escola, linhas in grupos.items():
        # título do anexo
        titulo = doc.add_paragraph(f"ANEXO – {escola}")
        titulo.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT
        for run in titulo.runs:
            run.font.name = "Arial"
            run.font.size = Pt(6)
            run.bold = True

        doc.add_paragraph("")

        # tabela
        linhas_qtd = len(linhas)
        colunas_qtd = len(linhas[0])

        tabela = doc.add_table(rows=linhas_qtd, cols=colunas_qtd)
        tabela.style = "Table Grid"

        for i, linha in enumerate(linhas):
            for j, valor in enumerate(linha):
                cell = tabela.cell(i, j)
                cell.text = str(valor)
                for p in cell.paragraphs:
                    for run in p.runs:
                        run.font.name = "Arial"
                        run.font.size = Pt(6)

        doc.add_paragraph("")  # espaço entre anexos

    return doc

import re

def clean_xml_string(text):
    if not isinstance(text, str):
        text = str(text)
    # Remove control characters except for tab, newline, and carriage return
    # and other non-XML compatible characters based on XML 1.0 specifications
    return re.sub(u'[\x00-\x08\x0b\x0c\x0e-\x1f\ud800-\udfff\ufffe\uffff]', '', text)

# Defina o texto padrão da portaria aqui
texto_padrao = """
PORTARIA N° XXXX/YYYY-GS/SEDUC

O(A) SECRETÁRIO(A) DE ESTADO DE EDUCAÇÃO DO PARÁ, no uso de suas atribuições legais e em conformidade com a legislação vigente, RESOLVE:

Art. 1º. CONCEDER [tipo_de_licença] aos(às) servidores(as) relacionados(as) no ANEXO a esta portaria, conforme disposto no(a) [legislação_aplicável].

Art. 2º. Esta portaria entra em vigor na data de sua publicação.

Dê-se ciência, registre-se, publique-se e cumpra-se.

[LOCAL], [DATA]

[NOME_DO_SECRETARIO]
Secretário(a) de Estado de Educação
"""

# Clean texto_padrao before passing it to the function
cleaned_texto_padrao = clean_xml_string(texto_padrao)

doc = criar_portaria_docx_com_anexos(
    cleaned_texto_padrao,
    grupos_escolas
)

arquivo = "PORTARIA - COLETIVA POR ESCOLA.docx"
doc.save(arquivo)

print("Documento gerado com sucesso:")
print(arquivo)

from google.colab import output

def gerar_portaria_python(link):
    # Insira aqui a chamada para as funções do seu PDF
    print(f"Processando link: {link}")
    # extrair_id(link) -> ler_aba() -> criar_portaria_docx_com_anexos()

output.register_callback('gerar_portaria_python', gerar_portaria_python)

import re
from google.colab import output, auth
from IPython.display import display, HTML

# Autenticação necessária para acessar o Sheets
auth.authenticate_user()

# Função que será chamada pelo botão do Frontend
def processar_geracao_portaria(link, aba, coluna_escola):
    try:
        # 1. Extração do ID do link (Lógica do seu PDF)
        match = re.search(r"/d/([a-zA-Z0-9-]+)", link)
        spreadsheet_id = match.group(1) if match else link.strip()

        print(f"✅ Conectado à planilha: {spreadsheet_id}")
        print(f"✅ Aba selecionada: {aba}")
        print(f"✅ Agrupando pela coluna: {coluna_escola}")

        # Aqui você chamaria as funções de ler_aba e criar_portaria_docx
        # que estão no seu PDF.

        return {"status": "success", "message": "Documento gerado com sucesso!"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

# REGISTRA A FUNÇÃO NO COLAB (Isso resolve o erro da sua imagem)
output.register_callback('notebook.processar_geracao_portaria', processar_geracao_portaria)

# @title
import re, io
from google.colab import auth, output, files
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload, MediaIoBaseUpload
from IPython.display import display, HTML
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from collections import defaultdict

# --- 1. CONFIGURAÇÃO INICIAL ---
auth.authenticate_user()
sheets_service = build('sheets', 'v4')
drive_service = build('drive', 'v3')

def extrair_id(link):
    m = re.search(r"/d/([a-zA-Z0-9-]+)", link)
    return m.group(1) if m else link.strip()

# --- 2. BACKEND (LOGICA DE FILTRO POR ID ÚNICO) ---

def obter_colunas_v15(link, aba):
    try:
        sid = extrair_id(link)
        # Lemos a linha 2 da aba específica
        result = sheets_service.spreadsheets().values().get(
            spreadsheetId=sid, range=f"'{aba}'!A2:Z2").execute()
        valores = result.get('values', [[]])
        if not valores[0]: return ["Erro: Aba vazia ou sem cabeçalho na linha 2"]

        cabecalho = valores[0]
        labels = []
        for i, n in enumerate(cabecalho):
            nome = n.strip() if n.strip() else f"Coluna {chr(65+i)}"
            # Criamos um ID único: "0|NOME", "1|NOME", etc.
            labels.append(f"{i}|{nome}")
        return labels
    except Exception as e: return [f"Erro: {str(e)}"]

def processar_v15(link, aba, letra_escola, exc, excluir_str, formato):
    try:
        sid = extrair_id(link)
        result = sheets_service.spreadsheets().values().get(spreadsheetId=sid, range=f"'{aba}'!A:Z").execute()
        linhas_todas = result.get('values', [])

        if len(linhas_todas) < 2: return "❌ Erro: Planilha insuficiente."

        cabecalho_original = linhas_todas[1] # Linha 2
        idx_esc = ord(letra_escola.upper()) - ord('A')

        # Lista de índices numéricos para remover
        indices_para_remover = [int(i) for i in excluir_str.split(',') if i.strip()]

        # Define as colunas que FICAM (ID e Nome)
        colunas_que_ficam = []
        for i in range(len(cabecalho_original)):
            if i not in indices_para_remover:
                nome_col = cabecalho_original[i].strip() if cabecalho_original[i].strip() else f"Col {i}"
                colunas_que_ficam.append((i, nome_col))

        # Agrupamento (Dados da Linha 3 em diante)
        grupos = defaultdict(list)
        for linha in linhas_todas[2:]:
            if not linha or len(linha) <= idx_esc: continue

            # Filtro de exclusão por palavra
            texto_linha = " ".join(map(str, linha)).lower()
            if exc and exc.lower() in texto_linha: continue

            escola = str(linha[idx_esc]).strip()
            if not escola or escola == "(automático)": continue # Limpa lixo da planilha

            # Extrai apenas as células das colunas que não foram marcadas
            dados_filtrados = []
            for idx_col, _ in colunas_que_ficam:
                valor = str(linha[idx_col] if idx_col < len(linha) else "").strip()
                dados_filtrados.append(valor)

            grupos[escola].append(dados_filtrados)

        # GERAÇÃO DO DOC
        doc = Document()
        p = doc.add_paragraph("PORTARIA N° XXXX/2026-GS/SEDUC")
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        p2 = doc.add_paragraph("O(A) SECRETÁRIO(A) DE ESTADO DE EDUCAÇÃO DO PARÁ, no uso de suas atribuições...")
        p2.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        for escola, lista_dados in grupos.items():
            doc.add_paragraph("").add_run(f"ANEXO - {escola}").bold = True
            tabela = doc.add_table(rows=1, cols=len(colunas_que_ficam))
            tabela.style = 'Table Grid'

            # Cabeçalho da Tabela Word
            for j, (_, nome_col) in enumerate(colunas_que_ficam):
                celula = tabela.cell(0, j)
                celula.text = nome_col
                for p_cell in celula.paragraphs:
                    for r in p_cell.runs: r.font.name = "Arial"; r.font.size = Pt(6); r.bold = True

            # Dados da Tabela
            for registro in lista_dados:
                row_cells = tabela.add_row().cells
                for j, valor in enumerate(registro):
                    row_cells[j].text = valor
                    for p_cell in row_cells[j].paragraphs:
                        for r in p_cell.runs: r.font.name = "Arial"; r.font.size = Pt(6)
            doc.add_paragraph("")

        # Stream e Conversão
        stream = io.BytesIO()
        doc.save(stream)
        stream.seek(0)

        nome_f = f"PORTARIA_{aba}_FINAL"
        media = MediaIoBaseUpload(stream, mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document')
        gdoc = drive_service.files().create(body={'name': nome_f, 'mimeType': 'application/vnd.google-apps.document'}, media_body=media).execute()

        if formato == 'PDF':
            req = drive_service.files().export_media(fileId=gdoc['id'], mimeType='application/pdf')
            pdf_fh = io.BytesIO()
            downloader = MediaIoBaseDownload(pdf_fh, req)
            done = False
            while not done: _, done = downloader.next_chunk()
            with open(f"{nome_f}.pdf", "wb") as f: f.write(pdf_fh.getvalue())
            drive_service.files().delete(fileId=gdoc['id']).execute()
            files.download(f"{nome_f}.pdf")
            return "✅ PDF da BASE III gerado com sucesso!"

        return f"✅ Google Docs gerado! <a href='https://docs.google.com/document/d/{gdoc['id']}/edit' target='_blank'>ABRIR {aba}</a>"

    except Exception as e: return f"❌ Erro: {str(e)}"

output.register_callback('notebook.obter_colunas', obter_colunas_v15)
output.register_callback('notebook.processar_v15', processar_v15)

# --- 3. INTERFACE (FRONTEND) ---
interface_html = """
<div style="background:#050a1f; color:white; padding:30px; border-radius:15px; max-width:700px; margin:auto; font-family:sans-serif; border: 1px solid #1e3a8a;">
    <h2 style="color:#14b8a6; text-align:center;">Gerador SEDUC v15 - Multi-Abas</h2>

    <label style="font-size:11px;">LINK DA PLANILHA</label>
    <input type="text" id="link" style="width:100%; padding:10px; margin-bottom:10px; background:#0f172a; border:1px solid #334155; color:white; border-radius:5px;">

    <div style="display:flex; gap:10px; margin-bottom:20px;">
        <input type="text" id="aba" placeholder="Nome da Aba (ex: BASE III)" style="flex:2; padding:10px; background:#0f172a; border:1px solid #334155; color:white;">
        <button onclick="carregar()" style="flex:1; background:#14b8a6; color:#050a1f; font-weight:bold; cursor:pointer; border:none; border-radius:5px;">LER CABEÇALHO</button>
    </div>

    <div id="check_area" style="display:none; background:rgba(255,255,255,0.05); padding:15px; border-radius:10px; margin-bottom:20px;">
        <p style="font-size:12px; color:#fbbf24;"><b>CHECKLIST DE EXCLUSÃO:</b> Selecione as colunas que NÃO quer no Word/PDF.</p>
        <div id="lista_c" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;"></div>
    </div>

    <div style="display:flex; gap:10px; margin-bottom:20px;">
        <div style="flex:1"><label style="font-size:11px;">COLUNA ESCOLA (LETRA)</label><input type="text" id="esc" value="C" style="width:100%; padding:10px; background:#0f172a; border:1px solid #334155; color:white;"></div>
        <div style="flex:1"><label style="font-size:11px;">NÃO CONTER (FILTRO)</label><input type="text" id="exc" placeholder="Ex: CANCELADO" style="width:100%; padding:10px; background:#0f172a; border:1px solid #334155; color:white;"></div>
    </div>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
        <button onclick="gerar('DOCS')" style="padding:15px; background:#4285f4; color:white; font-weight:bold; border:none; border-radius:8px; cursor:pointer;">GERAR GOOGLE DOCS</button>
        <button onclick="gerar('PDF')" style="padding:15px; background:#ea4335; color:white; font-weight:bold; border:none; border-radius:8px; cursor:pointer;">BAIXAR EM PDF</button>
    </div>

    <div id="st" style="margin-top:15px; text-align:center; color:#fbbf24; font-weight:bold;"></div>
</div>

<script>
    async function carregar() {
        const res = await google.colab.kernel.invokeFunction('notebook.obter_colunas', [document.getElementById('link').value, document.getElementById('aba').value], {});
        const dados = res.data['text/plain'].replace(/[\[\]']/g, '').split(',');
        let h = '';
        dados.forEach(item => {
            const p = item.split('|');
            if(p.length > 1) h += `<label style="font-size:10px;"><input type="checkbox" class="c-idx" value="${p[0].trim()}"> ${p[1].trim()}</label>`;
        });
        document.getElementById('lista_c').innerHTML = h;
        document.getElementById('check_area').style.display = 'block';
    }

    async function gerar(f) {
        const ids = [];
        document.querySelectorAll('.c-idx').forEach(c => { if(c.checked) ids.push(c.value); });
        document.getElementById('st').innerHTML = "⏳ Processando aba " + document.getElementById('aba').value + "...";
        const res = await google.colab.kernel.invokeFunction('notebook.processar_v15',
            [document.getElementById('link').value, document.getElementById('aba').value,
             document.getElementById('esc').value, document.getElementById('exc').value, ids.join(','), f], {});
        document.getElementById('st').innerHTML = res.data['text/plain'];
    }
</script>
"""
display(HTML(interface_html))